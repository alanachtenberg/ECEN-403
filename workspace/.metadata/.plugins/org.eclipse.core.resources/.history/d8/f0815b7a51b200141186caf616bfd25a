/*
 * main.c
 */

/* Note from the datasheet: In PWM mode, timers are configured as 24-bit or 48-bit down-counter with assigned
start value (corresponding to period) defined by GPTMTnILR and GPTMTnPR registers.
*/

#include "inc/hw_memmap.h"
#include "inc/hw_types.h"
#include "inc/hw_ints.h"
#include "driverlib/interrupt.h"
#include "driverlib/pin_map.h"
#include "driverlib/gpio.h"
#include "driverlib/timer.h"
#include "driverlib/debug.h"
#include "driverlib/sysctl.h" //sysctl calls for enabling peripherals
#include "driverlib/adc.h"	  //definitions for the adc driver
#include "driverlib/uart.h"
#include "inc/hw_gpio.h"
#include "utils/ustdlib.h"
#include "utils/uartstdio.h"
#include "utils/cmdline.h"
/*
 * if a driver library API is called with incorrect parameters or a library function generates an
 *  error for some other reason. The following code will be executed
 */

#define ADC_PORT GPIO_PORTB_BASE
#define ADC_PIN GPIO_PIN_5
#define SYSTEM_VOLTAGE_MV 3300//millivolts
#define ADC_RESOLUTION 4096
#ifdef DEBUG
void__error__(char *pcFilename, unsigned long ulLine)
{
}
#endif

unsigned long ulADC0Value[4]; //array size matches fifo depth of ADC sequencer 1

volatile unsigned long voltage;

int main(void){
	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);

	//sets clock to 40 Mhz
	SysCtlClockSet(SYSCTL_SYSDIV_5 | SYSCTL_USE_PLL | SYSCTL_XTAL_16MHZ | SYSCTL_OSC_MAIN);

	SysCtlPeripheralEnable(SYSCTL_PERIPH_ADC0); //enable the adc
	SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);//enable GPIO port B
	GPIOPinTypeGPIOInput(ADC_PORT,ADC_PIN);
	GPIOPinTypeADC(ADC_PORT,ADC_PIN);//sets
	SysCtlADCSpeedSet(SYSCTL_ADCSPEED_250KSPS); //set the sample freq to 250 khz
	//sequence sample period is 1/250Khz, total sampling period is 4/250khz
	ADCSequenceDisable(ADC0_BASE, 1);//disables adc sequencer 1, we will configure it and re-enable it later

	ADCSequenceConfigure(ADC0_BASE, 1, ADC_TRIGGER_PROCESSOR, 0); //configures the adc to use sequencer 1, be triggered by the processor, and have the highest priority 0
	//ch 11 is pb5
	ADCSequenceStepConfigure(ADC0_BASE, 1, 0, ADC_CTL_CH11);//configures the sequence 0 to read the temperature
	ADCSequenceStepConfigure(ADC0_BASE, 1, 1, ADC_CTL_CH11);//repeat for sequence 1
	ADCSequenceStepConfigure(ADC0_BASE, 1, 2, ADC_CTL_CH11);//repeat for sequence 2
	ADCSequenceStepConfigure(ADC0_BASE, 1, 3, ADC_CTL_CH11 | ADC_CTL_IE | ADC_CTL_END);//configures the final step to notify the processor it has completed its sequence vie interrupt
	//adc_ctl_end notifies the adc that the sequence has been completed

	ADCSequenceEnable(ADC0_BASE, 1);//configuration done, time to reenable the sequencer
	ADCIntEnable(ADC0_BASE,1);//enables interrupt for the adc0 on sequencer 1
	IntEnable(INT_ADC0SS1);
	IntMasterEnable();
	while(1){
		ADCProcessorTrigger(ADC0_BASE, 1);//triggers the adc conversion with software
	}

//
//
// PWM CODE (Project 4) STARTS HERE
//
//

unsigned long ulPeriod; // sets the period, and thus frequency, of our PWM
unsigned long dutyCycle3;

/* Reference: DataSheet - 1.3.4.4 CCP Pins (under Architectural Overview)
* CCP Pins can be used by GPTM (see Lab 4 in the workbook) to time/count
external events with CCP pin as input. GPTM can also generate a PWM output on CCP
pin.
* For PWM, the GPTM is incremented (or decremented) by system clock. The
PWM signal (which is output) is generated based on match between counter value and
value stored in match register.
*/

// Configure pin PB6 as Timer_0 CCP0
GPIOPinConfigure(GPIO_PB6_T0CCP0); // Configure pin PB6 as Timer 0_A output

/* Note that if you get errors here, you may have to replace the named terms
for actual hex address, found in header file. */

GPIOPinTypeTimer(GPIO_PORTB_BASE, GPIO_PIN_6 ); // Enable pin PB6 as output of timer addressed to it

// SysCtlClockGet() will give you the number of clock cycles in 1 second. This
// is convenient for directly converting to clock frequency division, as one second
// corresponds to one Hertz.

ulPeriod = (SysCtlClockGet() / 500)/2;
dutyCycle = variable value set by ADC;
SysCtlPeripheralEnable(SYSCTL_PERIPH_TIMER0); // Enable Timer 0

// Configure the timers as split 16-bit pairs, and set each timer as PWM mode.
TimerConfigure(TIMER0_BASE, (TIMER_CFG_SPLIT_PAIR|TIMER_CFG_A_PWM|TIMER_CFG_B_PWM));
TimerControlLevel(TIMER0_BASE, TIMER_BOTH, 0); // Timer 0 is trigger low

// For simplicity, we don't use PWM interrupts, for which we would need to configure the TnEVENT field in GPTMCTL and enable
// For simplicity, we don't use prescaler load and match set here. If we do use prescaler, the API functions would write value to GPTM Timer nPrescale Reg (GPTMTnPR)*/
// These API functions load the timer start value into Timer n Interval Load Reg (GPTMTnILR) Reg 10, 11

// Timer 0 Load set
 TimerLoadSet(TIMER0_BASE, TIMER_B, ulPeriod -1);
// These API functions load the match value into Timer n Match register(GPTMTnMATCHR)

 // Timer 0 Match set
 TimerMatchSet(TIMER0_BASE, TIMER_A, dutyCycle3);


/* Timers are now configured. */

 // Finally, enable the timers, which will now run (API functions will set TnENbit in Reg 4 (GPTMCTL)
 TimerEnable(TIMER0_BASE, TIMER_BOTH);

 // Continuous while loop, and Timers will be counting in PWM mode
 while(1){
 }
}

//handler is declared in nvic, n startup_css.c
void SequenceIntHandler(void){
			ADCIntClear(ADC0_BASE,1);//clear the interrupt


			ADCSequenceDataGet(ADC0_BASE, 1, ulADC0Value);//copies sequence data into our buffer
			unsigned long ac_voltage[4];
			int i=0;
			for (i=0;i<4;++i){
			ac_voltage[i]=(ulADC0Value[i]*SYSTEM_VOLTAGE_MV)/ADC_RESOLUTION;//voltage in millivolts
			}
}
